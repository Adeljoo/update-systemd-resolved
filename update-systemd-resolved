#!/bin/bash
#
# OpenVPN helper to add DHCP information into systemd-resolved via DBus.
# Copyright (C) 2016, Jonathan Wright <jon@than.io>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This script will parse DHCP options set via OpenVPN (dhcp-option) to update
# systemd-resolved directly via DBus, instead of updating /etc/resolv.conf. To
# install, set as the 'up' and 'down' script in your OpenVPN configuration file
# or command-line argument. For example:
#   up /etc/openvpn/update-systemd-resolved
#   down /etc/openvpn/update-systemd-resolved

# Abort if the environment is missing
[[ -z ${script_type} || -z "${dev}" ]] && exit 0

# Get ifindex for the interface
IP_LINK="$(ip link show dev ${dev})"
IF_INDEX="${IP_LINK//:*}"
# Abort if ifindex not found
[[ -z "${IF_INDEX}" ]] && exit 0

# Define what needs to be called via DBus
DBUS_DEST="org.freedesktop.resolve1"
DBUS_NODE="/org/freedesktop/resolve1"

# Preset values for processing
dns_server_count=0
dns_servers=""
dns_domain_count=""
dns_domains=""

function log() {
  logger -t update-systemd-resolved "${@}"
}

log "Called on ${script_type}"
case $script_type in
  up)
    for foreign_option in ${!foreign_option_*} ; do
      option="${!foreign_option}"
      [[ "${option// *}" == "dhcp-option" ]] || continue
      setting="${option//dhcp-option }"
      log "${setting}"
      case "${setting// *}" in
        DNS)
          address="${setting//DNS }"
          [[ -z "${address}" ]] && continue
          dns_server_count=$((dns_server_count+1))
          if [[ "${address}" =~ ":" ]]; then
            log "Adding IPv6 DNS Server ${address}"
            # The following is a placeholder. Will need a way to convert to
            # full address and then break into a 16 byte array
            #   dns_servers="2 16 ${address//:/ }"
          else
            log "Adding IPv4 DNS Server ${address}"
            dns_servers="${dns_servers} 2 4 ${address//./ }"
          fi
          ;;
        DOMAIN)
          domain="${setting//DOMAIN }"
          [[ -z "${domain}" ]] && continue
          dns_domain_count=$((dns_domain_count+1))
          log "Adding DNS Domain ${address}"
          dns_domains="${dns_domains} ${domain} false"
          ;;
        DOMAIN-SEARCH)
          domain="${setting//DOMAIN-SEARCH }"
          [[ -z "${domain}" ]] && continue
          dns_domain_count=$((dns_domain_count+1))
          log "Adding DNS Search Domain ${address}"
          dns_domains="${dns_domains} ${domain} true"
          ;;
      esac
    done

    [[ ${dns_server_count} -gt 0 ]] && \
      log "SetLinkDNS(${IF_INDEX} ${dns_server_count}${dns_servers})" && \
      busctl call ${DBUS_DEST} ${DBUS_NODE} ${DBUS_DEST}.Manager \
        SetLinkDNS "ia(iay)" ${IF_INDEX} ${dns_server_count}${dns_servers}

    [[ ${dns_domain_count} -gt 0 ]] && \
      log "SetLinkDomains(${IF_INDEX} ${dns_domain_count}${dns_domains})" && \
      busctl call ${DBUS_DEST} ${DBUS_NODE} ${DBUS_DEST}.Manager \
        SetLinkDomains "ia(sb)" ${IF_INDEX} ${dns_domain_count}${dns_domains}

    ;;
  down)
    log "${0} down"
    busctl call ${DBUS_DEST} ${DBUS_NODE} ${DBUS_DEST}.Manager \
      RevertLink i ${IF_INDEX}
    ;;

esac
